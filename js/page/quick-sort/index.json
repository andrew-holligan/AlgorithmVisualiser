{
    "Default": 
    {
        "description":[
            "This algorithm works by selecting a pivot element (the right-most element in the array) and pushing all elements smaller than it before it in the array.",
            "Thus the pivot element is in its final position in the array.",
            "We repeat this for both the left and right sub-arrays of the pivot element."
        ],
        "complexity":{
            "best-case":"O(nlogn)",
            "worst-case":"O(n^2)",
            "average-case":"O(nlogn)",
            "space":"O(1)"
        },
        "implementation": {
            "javascript":[
                "function partition(arr, l, r) {",
                "",
                "  let pivot = arr[r];",
                "  let i = l - 1;",
                "",
                "  for (let j = l; j <= r - 1; j++) {",
                "    if (arr[j] <= pivot) {",
                "      i++;",
                "      [arr[i], arr[j]] = [arr[j], arr[i]];",
                "    }",
                "  }",
                "",
                "  [arr[i + 1], arr[r]] = [arr[r], arr[i + 1]];",
                "  return i + 1;",
                "",
                "}",
                "",
                "",
                "function quickSort(arr, l, r) {",
                "",
                "  if (l < r) {",
                "    let pivotI = partition(arr, l, r);",
                "    quickSort(arr, l, pivotI - 1);",
                "    quickSort(arr, pivotI + 1, r);",
                "  }",
                "",
                "}"
            ],
            "java":[
                "public void partition(int[] arr, int l, int r) {",
                "",
                "  int pivot = arr[r];",
                "  int i = l - 1;",
                "",
                "  for (int j = l; j <= r - 1; j++) {",
                "    if (arr[j] <= pivot) {",
                "      i++;",
                "      int temp = arr[i];",
                "      arr[i] = arr[j];",
                "      arr[j] = temp;",
                "    }",
                "  }",
                "",
                "  int temp = arr[i + 1];",
                "  arr[i + 1] = arr[r];",
                "  arr[r] = temp;",
                "  return i + 1;",
                "",
                "}",
                "",
                "",
                "public void quickSort(int[] arr, int l, int r) {",
                "",
                "  if (l < r) {",
                "    int pivotI = partition(arr, l, r);",
                "    quickSort(arr, l, pivotI - 1);",
                "    quickSort(arr, pivotI + 1, r);",
                "  }",
                "",
                "}"
            ],
            "python":[
                "def partition(arr, l, r):",
                "",
                "  pivot = arr[r]",
                "  i = l - 1",
                "",
                "  for j in range(l, r):",
                "    if arr[j] <= pivot:",
                "      i += 1",
                "      arr[i], arr[j] = arr[j], arr[i]",
                "",
                "  arr[i + 1], arr[r] = arr[r], arr[i + 1]",
                "  return i + 1",
                "",
                "",
                "def quickSort(arr, l, r):",
                "",
                "  if l < r:",
                "    pivotI = partition(arr, l, r)",
                "    quickSort(arr, l, pivotI - 1)",
                "    quickSort(arr, pivotI + 1, r)"
            ],
            "cpp":[
                "STILL TO IMPLEMENT"
            ],
            "csharp":[
                "STILL TO IMPLEMENT"
            ],
            "c":[
                "STILL TO IMPLEMENT"
            ]
        }
    },

    "ThreeWay": 
    {
        "description":[
            "This variant is similar to the default quicksort.",
            "The difference being that it splits the array into sub arrays: elements less than pivot, elements equal, elements greater.",
            "Then we only recurse into the less than and greater than subarrays since the equal array is already sorted."
        ],
        "complexity":{
            "best-case":"O(n)",
            "worst-case":"O(n^2)",
            "average-case":"O(nlogn)",
            "space":"O(1)"
        },
        "implementation": {
            "javascript":[
                "function partition(arr, l, r) {",
                "",
                "  let pivot = arr[r];",
                "  let i = l - 1;",
                "  let j = l - 1;",
                "",
                "  for (let index = l; index <= r - 1; index++) {",
                "    if (arr[index] <= pivot) {",
                "      i++;",
                "      j++;",
                "      [arr[i], arr[index]] = [arr[index], arr[i]];",
                "    }",
                "  }",
                "",
                "  for (let index = l; index <= r - 1; index++) {",
                "    if (arr[index] === pivot) {",
                "      j++;",
                "      [arr[j], arr[index]] = [arr[index], arr[j]];",
                "    }",
                "  }",
                "",
                "  [arr[j + 1], arr[r]] = [arr[r], arr[j + 1]];",
                "  j++;",
                "  j++;",
                "  return [i, j];",
                "",
                "}",
                "",
                "",
                "function quickSort(arr, l, r) {",
                "",
                "  if (l < r) {",
                "    let pivotIndices = partition(arr, l, r);",
                "    let i = pivotIndices[0];",
                "    let j = pivotIndices[1];",
                "",
                "    quickSort(arr, l, i);",
                "    quickSort(arr, j, r);",
                "  }",
                "",
                "}"
            ],
            "java":[
                "public void partition(int[] arr, int l, int r) {",
                "",
                "  int pivot = arr[r];",
                "  int i = l - 1;",
                "  int j = l - 1;",
                "",
                "  for (int index = l; index <= r - 1; index++) {",
                "    if (arr[index] <= pivot) {",
                "      i++;",
                "      j++;",
                "      int temp = arr[i];",
                "      arr[i] = arr[index];",
                "      arr[index] = temp;",
                "    }",
                "  }",
                "",
                "  for (int index = l; index <= r - 1; index++) {",
                "    if (arr[index] == pivot) {",
                "      j++;",
                "      int temp = arr[j];",
                "      arr[j] = arr[index];",
                "      arr[index] = temp;",
                "    }",
                "  }",
                "",
                "  int temp = arr[j + 1];",
                "  arr[j + 1] = arr[r];",
                "  arr[r] = temp;",
                "  j++;",
                "  j++;",
                "  return new int[] {i, j};",
                "",
                "}",
                "",
                "",
                "public void quickSort(int[] arr, int l, int r) {",
                "",
                "  if (l < r) {",
                "    int[] pivotIndices = partition(arr, l, r);",
                "    int i = pivotIndices[0];",
                "    int j = pivotIndices[1];",
                "",
                "    quickSort(arr, l, i);",
                "    quickSort(arr, j, r);",
                "  }",
                "",
                "}"
            ],
            "python":[
                "def partition(arr, l, r):",
                "",
                "  pivot = arr[r]",
                "  i = l - 1",
                "  j = l - 1",
                "",
                "  for index in range(l, r):",
                "    if arr[index] <= pivot:",
                "      i += 1",
                "      j += 1",
                "      arr[i], arr[index] = arr[index], arr[i]",
                "",
                "  for index in range(l, r):",
                "    if arr[index] == pivot:",
                "      j += 1",
                "      arr[j], arr[index] = arr[index], arr[j]",
                "",
                "  arr[j + 1], arr[r] = arr[r], arr[j + 1]",
                "  j += 1",
                "  j += 1",
                "  return [i, j]",
                "",
                "}",
                "",
                "",
                "def quickSort(arr, l, r):",
                "",
                "  if l < r:",
                "    pivotIndices = partition(arr, l, r)",
                "    i = pivotIndices[0]",
                "    j = pivotIndices[1]",
                "",
                "    quickSort(arr, l, i)",
                "    quickSort(arr, j, r)"
            ],
            "cpp":[
                "STILL TO IMPLEMENT"
            ],
            "csharp":[
                "STILL TO IMPLEMENT"
            ],
            "c":[
                "STILL TO IMPLEMENT"
            ]
        }
    }
}